/* This autogenerated file is part of jpcsp. */
/*
This file is part of jpcsp.

Jpcsp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Jpcsp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Jpcsp.  If not, see <http://www.gnu.org/licenses/>.
 */

package jpcsp.HLE.modules150;

import java.util.Random;

import jpcsp.HLE.Modules;
import jpcsp.HLE.modules.HLEModule;
import jpcsp.HLE.modules.HLEModuleFunction;
import jpcsp.HLE.modules.HLEModuleManager;

import jpcsp.HLE.kernel.managers.SceUidManager;
import jpcsp.HLE.kernel.types.SceMpegRingbuffer;

import jpcsp.Memory;
import jpcsp.Processor;

import jpcsp.Allegrex.CpuState; // New-Style Processor

// TODO we need to find out if any of these functions are blocking/invoke a context switch
public class sceMpeg implements HLEModule {
    @Override
    public String getName() { return "sceMpeg"; }

    @Override
    public void installModule(HLEModuleManager mm, int version) {
        if (version >= 150) {

            mm.addFunction(sceMpegQueryStreamOffsetFunction, 0x21FF80E4);
            mm.addFunction(sceMpegQueryStreamSizeFunction, 0x611E9E11);
            mm.addFunction(sceMpegInitFunction, 0x682A619B);
            mm.addFunction(sceMpegFinishFunction, 0x874624D6);
            mm.addFunction(sceMpegQueryMemSizeFunction, 0xC132E22F);
            mm.addFunction(sceMpegCreateFunction, 0xD8C5F121);
            mm.addFunction(sceMpegDeleteFunction, 0x606A4649);
            mm.addFunction(sceMpegRegistStreamFunction, 0x42560F23);
            mm.addFunction(sceMpegUnRegistStreamFunction, 0x591A4AA2);
            mm.addFunction(sceMpegMallocAvcEsBufFunction, 0xA780CF7E);
            mm.addFunction(sceMpegFreeAvcEsBufFunction, 0xCEB870B1);
            mm.addFunction(sceMpegQueryAtracEsSizeFunction, 0xF8DCB679);
            mm.addFunction(sceMpegQueryPcmEsSizeFunction, 0xC02CF6B5);
            mm.addFunction(sceMpegInitAuFunction, 0x167AFD9E);
            mm.addFunction(sceMpegChangeGetAvcAuModeFunction, 0x234586AE);
            mm.addFunction(sceMpegChangeGetAuModeFunction, 0x9DCFB7EA);
            mm.addFunction(sceMpegGetAvcAuFunction, 0xFE246728);
            mm.addFunction(sceMpegGetPcmAuFunction, 0x8C1E027D);
            mm.addFunction(sceMpegGetAtracAuFunction, 0xE1CE83A7);
            mm.addFunction(sceMpegFlushStreamFunction, 0x500F0429);
            mm.addFunction(sceMpegFlushAllStreamFunction, 0x707B7629);
            mm.addFunction(sceMpegAvcDecodeFunction, 0x0E3C2E9D);
            mm.addFunction(sceMpegAvcDecodeDetailFunction, 0x0F6C18D7);
            mm.addFunction(sceMpegAvcDecodeModeFunction, 0xA11C7026);
            mm.addFunction(sceMpegAvcDecodeStopFunction, 0x740FCCD1);
            mm.addFunction(sceMpegAvcDecodeFlushFunction, 0x4571CC64);
            mm.addFunction(sceMpegAvcQueryYCbCrSizeFunction, 0x211A057C);
            mm.addFunction(sceMpegAvcInitYCbCrFunction, 0x67179B1B);
            mm.addFunction(sceMpegAvcDecodeYCbCrFunction, 0xF0EB1125);
            mm.addFunction(sceMpegAvcDecodeStopYCbCrFunction, 0xF2930C9C);
            mm.addFunction(sceMpegAvcCscFunction, 0x31BD0272);
            mm.addFunction(sceMpegAtracDecodeFunction, 0x800C44DF);
            mm.addFunction(sceMpegRingbufferQueryMemSizeFunction, 0xD7A29F46);
            mm.addFunction(sceMpegRingbufferConstructFunction, 0x37295ED8);
            mm.addFunction(sceMpegRingbufferDestructFunction, 0x13407F13);
            mm.addFunction(sceMpegRingbufferPutFunction, 0xB240A59E);
            mm.addFunction(sceMpegRingbufferAvailableSizeFunction, 0xB5F6DC87);
            mm.addFunction(sceMpeg_11CAB459Function, 0x11CAB459);
            mm.addFunction(sceMpegNextAvcRpAuFunction, 0x3C37A7A6);
            mm.addFunction(sceMpeg_B27711A8Function, 0xB27711A8);
            mm.addFunction(sceMpeg_D4DD6E75Function, 0xD4DD6E75);
            mm.addFunction(sceMpeg_C345DED2Function, 0xC345DED2);
            mm.addFunction(sceMpeg_AB0E9556Function, 0xAB0E9556);
            mm.addFunction(sceMpegAvcDecodeDetail2Function, 0xCF3547A2);
            mm.addFunction(sceMpeg_988E9E12Function, 0x988E9E12);
        }

        mpegUid = -1;
    }

    @Override
    public void uninstallModule(HLEModuleManager mm, int version) {
        if (version >= 150) {

            mm.removeFunction(sceMpegQueryStreamOffsetFunction);
            mm.removeFunction(sceMpegQueryStreamSizeFunction);
            mm.removeFunction(sceMpegInitFunction);
            mm.removeFunction(sceMpegFinishFunction);
            mm.removeFunction(sceMpegQueryMemSizeFunction);
            mm.removeFunction(sceMpegCreateFunction);
            mm.removeFunction(sceMpegDeleteFunction);
            mm.removeFunction(sceMpegRegistStreamFunction);
            mm.removeFunction(sceMpegUnRegistStreamFunction);
            mm.removeFunction(sceMpegMallocAvcEsBufFunction);
            mm.removeFunction(sceMpegFreeAvcEsBufFunction);
            mm.removeFunction(sceMpegQueryAtracEsSizeFunction);
            mm.removeFunction(sceMpegQueryPcmEsSizeFunction);
            mm.removeFunction(sceMpegInitAuFunction);
            mm.removeFunction(sceMpegChangeGetAvcAuModeFunction);
            mm.removeFunction(sceMpegChangeGetAuModeFunction);
            mm.removeFunction(sceMpegGetAvcAuFunction);
            mm.removeFunction(sceMpegGetPcmAuFunction);
            mm.removeFunction(sceMpegGetAtracAuFunction);
            mm.removeFunction(sceMpegFlushStreamFunction);
            mm.removeFunction(sceMpegFlushAllStreamFunction);
            mm.removeFunction(sceMpegAvcDecodeFunction);
            mm.removeFunction(sceMpegAvcDecodeDetailFunction);
            mm.removeFunction(sceMpegAvcDecodeModeFunction);
            mm.removeFunction(sceMpegAvcDecodeStopFunction);
            mm.removeFunction(sceMpegAvcDecodeFlushFunction);
            mm.removeFunction(sceMpegAvcQueryYCbCrSizeFunction);
            mm.removeFunction(sceMpegAvcInitYCbCrFunction);
            mm.removeFunction(sceMpegAvcDecodeYCbCrFunction);
            mm.removeFunction(sceMpegAvcDecodeStopYCbCrFunction);
            mm.removeFunction(sceMpegAvcCscFunction);
            mm.removeFunction(sceMpegAtracDecodeFunction);
            mm.removeFunction(sceMpegRingbufferQueryMemSizeFunction);
            mm.removeFunction(sceMpegRingbufferConstructFunction);
            mm.removeFunction(sceMpegRingbufferDestructFunction);
            mm.removeFunction(sceMpegRingbufferPutFunction);
            mm.removeFunction(sceMpegRingbufferAvailableSizeFunction);
            mm.removeFunction(sceMpeg_11CAB459Function);
            mm.removeFunction(sceMpegNextAvcRpAuFunction);
            mm.removeFunction(sceMpeg_B27711A8Function);
            mm.removeFunction(sceMpeg_D4DD6E75Function);
            mm.removeFunction(sceMpeg_C345DED2Function);
            mm.removeFunction(sceMpeg_AB0E9556Function);
            mm.removeFunction(sceMpegAvcDecodeDetail2Function);
            mm.removeFunction(sceMpeg_988E9E12Function);

        }
    }

    // for now we just support 1 instance of mpeg
    protected int mpegUid;
    protected SceMpegRingbuffer mpegRingbuffer;
    protected int mpegRingbufferAddr;
    protected int mpegAtracCurrentTimestamp;
    protected int mpegAvcCurrentTimestamp;
    public static final boolean enableMpeg = false;

    public static final int PSMF_MAGIC = 0x464D5350;


    protected int makeFakeStreamHandle(int stream) {
        return 0x34340000 | (stream & 0xFFFF);
    }

    protected boolean isFakeStreamHandle(int handle) {
        return ((handle & 0xFFFF0000) == 0x34340000);
    }

    protected int getFakeStreamID(int handle) {
        return (handle & 0x0000FFFF);
    }

    protected boolean isFakeAuHandle(int handle) {
        return ((handle & 0xFFFF0000) == 0x56560000);
    }

    protected int getFakeAuType(int handle) {
        return (handle & 0x0000FFFF);
    }

    protected int getMpegUid(int mpegAddr) {
        Memory mem = Memory.getInstance();
        if (mem.isAddressGood(mpegAddr)) {
            return mem.read32(mpegAddr);
        }

        return -1;
    }

    protected int endianSwap(int x) {
        return (x << 24) | ((x << 8) &  0xFF0000) | ((x >> 8) &  0xFF00) | ((x >> 24) &  0xFF);
    }


    public void sceMpegQueryStreamOffset(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int buffer_addr = cpu.gpr[5];
        int offset_addr = cpu.gpr[6];

        Modules.log.debug("sceMpegQueryStreamOffset(mpeg=0x" + Integer.toHexString(mpeg)
            + ",buffer=0x" + Integer.toHexString(buffer_addr)
            + ",offset=0x" + Integer.toHexString(offset_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegQueryStreamOffset bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(buffer_addr) && mem.isAddressGood(offset_addr)) {
            int magic = mem.read32(buffer_addr);
            int version = mem.read32(buffer_addr + 4);
            int offset = endianSwap(mem.read32(buffer_addr + 8));
            int size = endianSwap(mem.read32(buffer_addr + 12));
            Modules.log.debug(String.format("sceMpegQueryStreamOffset magic=0x%08X"
                + " version=0x%08X offset=0x%08X size=0x%08X", magic, version, offset, size));

            if (magic == PSMF_MAGIC) {
                mem.write32(offset_addr, offset);
                cpu.gpr[2] = 0;
            } else {
                Modules.log.warn("sceMpegQueryStreamOffset bad magic " + String.format("0x%08X", magic));
                cpu.gpr[2] = -1;
            }
        } else {
            Modules.log.warn("sceMpegQueryStreamOffset bad address "
                + String.format("0x%08X 0x%08X", buffer_addr, offset_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegQueryStreamSize(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int buffer_addr = cpu.gpr[4];
        int size_addr = cpu.gpr[5];

        Modules.log.debug("sceMpegQueryStreamSize(buffer=0x" + Integer.toHexString(buffer_addr)
            + ",size=0x" + Integer.toHexString(size_addr) + ")");

        if (mem.isAddressGood(buffer_addr) && mem.isAddressGood(size_addr)) {
            int magic = mem.read32(buffer_addr);
            int version = mem.read32(buffer_addr + 4);
            int offset = endianSwap(mem.read32(buffer_addr + 8));
            int size = endianSwap(mem.read32(buffer_addr + 12));
            Modules.log.debug(String.format("sceMpegQueryStreamSize magic=0x%08X"
                + " version=0x%08X offset=0x%08X size=0x%08X", magic, version, offset, size));

            if (!enableMpeg) {
                // HACK: if fake 0 size maybe it won't play :)
                Modules.log.warn("sceMpegQueryStreamSize using fake size 0");
                size = 0;
            } else {
                // Round size to next block size
                size = (size + 2047) & ~2047;
            }

            if (magic == PSMF_MAGIC) {
                mem.write32(size_addr, size);
                cpu.gpr[2] = 0;
            } else {
                Modules.log.warn("sceMpegQueryStreamSize bad magic " + String.format("0x%08X", magic));
                cpu.gpr[2] = -1;
            }
        } else {
            Modules.log.warn("sceMpegQueryStreamSize bad address "
                + String.format("0x%08X 0x%08X", buffer_addr, size_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegInit(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        Modules.log.warn("PARTIAL:sceMpegInit");

        // we'll support only 1 mpeg instance at a time, we can fix this later if needed
        if (mpegUid != -1) {
            Modules.log.warn("UNIMPLEMENTED:sceMpegInit multiple instances not yet supported");
            cpu.gpr[2] = -1;
        } else {
            cpu.gpr[2] = 0;
        }
    }

    public void sceMpegFinish(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        Modules.log.warn("PARTIAL:sceMpegFinish");

        mpegUid = -1;

        // no return value
    }

    // user app will malloc this amount of memory
    public void sceMpegQueryMemSize(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        int mode = cpu.gpr[4];

        Modules.log.warn("PARTIAL:sceMpegQueryMemSize(mode=" + mode + ")");

        //cpu.gpr[2] = 0x20000; // TODO no idea what this should be, setting it to 128k
        cpu.gpr[2] = 512 * 4; // copied from noxa/pspplayer
    }

    public void sceMpegCreate(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int data = cpu.gpr[5];
        int size = cpu.gpr[6];
        int ringbuffer_addr = cpu.gpr[7];
        int frameWidth = cpu.gpr[8];
        int mode = cpu.gpr[9];
        int ddrtop = cpu.gpr[10];

        Modules.log.warn("PARTIAL:sceMpegCreate(mpeg=0x" + Integer.toHexString(mpeg)
            + ",data=0x" + Integer.toHexString(data)
            + ",size=" + size
            + ",ringbuffer=0x" + Integer.toHexString(ringbuffer_addr)
            + ",frameWidth=" + frameWidth
            + ",mode=" + mode
            + ",ddrtop=0x" + Integer.toHexString(ddrtop) + ")");

        if (mem.isAddressGood(mpeg) && mem.isAddressGood(data) && mem.isAddressGood(ringbuffer_addr)) {
            mpegUid = SceUidManager.getNewUid("sceMpeg-Mpeg");
            mem.write32(mpeg, mpegUid);
            Modules.log.warn("sceMpegCreate assigned uid " + Integer.toHexString(mpegUid));

            // update the ring buffer
            SceMpegRingbuffer ringbuffer = new SceMpegRingbuffer(mem, ringbuffer_addr);
            ringbuffer.packetSize = size;
            ringbuffer.packetsFree = (ringbuffer.dataUpperBound - ringbuffer.data) / ringbuffer.packetSize;
            ringbuffer.mpeg = mpegUid;
            ringbuffer.write(mem, ringbuffer_addr);

            mpegRingbufferAddr = ringbuffer_addr;
            mpegRingbuffer = ringbuffer;
            mpegAtracCurrentTimestamp = 0;
            mpegAvcCurrentTimestamp = 0;

            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegCreate bad address "
                + String.format("0x%08X 0x%08X 0x%08X", mpeg, data, ringbuffer_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegDelete(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        int mpeg = cpu.gpr[4];

        Modules.log.warn("PARTIAL:sceMpegDelete(mpeg=0x" + Integer.toHexString(mpeg) + ")");

        int uid = getMpegUid(mpeg);
        if (uid != mpegUid) {
            Modules.log.warn("sceMpegDelete bad mpeg handle 0x" + Integer.toHexString(mpeg) + " uid=" + Integer.toHexString(uid));
            cpu.gpr[2] = -1;
        } else {
            cpu.gpr[2] = 0;
        }
    }

    public void sceMpegRegistStream(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int stream = cpu.gpr[5];
        int unk = cpu.gpr[6];

        Modules.log.warn("PARTIAL:sceMpegRegistStream(mpeg=0x" + Integer.toHexString(mpeg)
            + ",stream=" + Integer.toHexString(stream)
            + ",unk=0x" + Integer.toHexString(unk) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegRegistStream bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else {
            // fake allocate a stream struct
            cpu.gpr[2] = makeFakeStreamHandle(stream);
            Modules.log.debug("sceMpegRegistStream ret=0x" + Integer.toHexString(cpu.gpr[2]));
        }
    }

    public void sceMpegUnRegistStream(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        int mpeg = cpu.gpr[4];
        int stream_addr = cpu.gpr[5];

        Modules.log.warn("PARTIAL:sceMpegUnRegistStream(mpeg=0x" + Integer.toHexString(mpeg)
            + ",stream=0x" + Integer.toHexString(stream_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegUnRegistStream bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (isFakeStreamHandle(stream_addr)) {
            Modules.log.debug("sceMpegUnRegistStream got fake stream ID " + getFakeStreamID(stream_addr));
            cpu.gpr[2] = 0;
        } else {
            cpu.gpr[2] = 0;
        }
    }

    public void sceMpegMallocAvcEsBuf(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        int mpeg = cpu.gpr[4];

        Modules.log.warn("PARTIAL:sceMpegMallocAvcEsBuf(mpeg=0x" + Integer.toHexString(mpeg) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegMallocAvcEsBuf bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else {
            cpu.gpr[2] = 0x12121212; // fake
            Modules.log.debug("sceMpegMallocAvcEsBuf ret=0x" + Integer.toHexString(cpu.gpr[2]));
        }
    }

    public void sceMpegFreeAvcEsBuf(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        int mpeg = cpu.gpr[4];
        int buffer_addr = cpu.gpr[5];

        Modules.log.warn("PARTIAL:sceMpegFreeAvcEsBuf(mpeg=0x" + Integer.toHexString(mpeg)
            + ",buffer=0x" + Integer.toHexString(buffer_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegFreeAvcEsBuf bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else {
            // we could check if buffer_addr == 0x12121212 from sceMpegMallocAvcEsBuf
            cpu.gpr[2] = 0;
        }
    }

    public void sceMpegQueryAtracEsSize(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int esSize_addr = cpu.gpr[5];
        int size_addr = cpu.gpr[6];

        Modules.log.warn("IGNORING:sceMpegQueryAtracEsSize(mpeg=0x" + Integer.toHexString(mpeg)
            + ",esSize=0x" + Integer.toHexString(esSize_addr)
            + ",size=0x" + Integer.toHexString(size_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegQueryAtracEsSize bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(esSize_addr) && mem.isAddressGood(size_addr)) {
            // TODO get the required data out of the mpeg stream

            // copied from noxa/pspplayer
            mem.write32(esSize_addr, 2112);
            mem.write32(size_addr, 8192);

            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegQueryAtracEsSize bad address "
                + String.format("0x%08X 0x%08X", esSize_addr, size_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegQueryPcmEsSize(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpegQueryPcmEsSize [0xC02CF6B5]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpegInitAu(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int buffer_addr = cpu.gpr[5];
        int au_addr = cpu.gpr[6]; // 136 byte struct?

        Modules.log.warn("IGNORING:sceMpegInitAu(mpeg=0x" + Integer.toHexString(mpeg)
            + ",buffer=0x" + Integer.toHexString(buffer_addr)
            + ",au=0x" + Integer.toHexString(au_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegInitAu bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else {
            // TODO
            // buffer_addr is from sceMpegMallocAvcEsBuf

            mem.write32(au_addr, 0x78787878);
            mem.write32(au_addr + 4, 0);    // iTimestamp

            cpu.gpr[2] = 0;
        }
    }

    public void sceMpegChangeGetAvcAuMode(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpegChangeGetAvcAuMode [0x234586AE]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpegChangeGetAuMode(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpegChangeGetAuMode [0x9DCFB7EA]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpegGetAvcAu(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int stream_addr = cpu.gpr[5];
        int au_addr = cpu.gpr[6];
        int unk_addr = cpu.gpr[7];

        Modules.log.warn("PARTIAL:sceMpegGetAvcAu(mpeg=0x" + Integer.toHexString(mpeg)
            + ",stream=0x" + Integer.toHexString(stream_addr)
            + ",au=0x" + Integer.toHexString(au_addr)
            + ",unknown=0x" + Integer.toHexString(unk_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegGetAvcAu bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(stream_addr) && mem.isAddressGood(au_addr)) {
            // TODO
            mem.write32(au_addr, 0x56560001);

            cpu.gpr[2] = 0;
        } else if (isFakeStreamHandle(stream_addr)) {
            Modules.log.debug("sceMpegGetAvcAu got fake stream ID " + getFakeStreamID(stream_addr));
            mem.write32(au_addr, 0x56560001);
            if (enableMpeg) {
                mem.write32(au_addr + 4, mpegAvcCurrentTimestamp);
            }
            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegGetAvcAu bad address "
                + String.format("0x%08X 0x%08X", stream_addr, au_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegGetPcmAu(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int stream_addr = cpu.gpr[5];
        int au_addr = cpu.gpr[6];
        int unk_addr = cpu.gpr[7];

        Modules.log.warn("PARTIAL:sceMpegGetPcmAu(mpeg=0x" + Integer.toHexString(mpeg)
            + ",stream=0x" + Integer.toHexString(stream_addr)
            + ",au=0x" + Integer.toHexString(au_addr)
            + ",unknown=0x" + Integer.toHexString(unk_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegGetPcmAu bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(stream_addr) && mem.isAddressGood(au_addr)) {
            // TODO
            mem.write32(au_addr, 0x56560002);

            cpu.gpr[2] = 0;
        } else if (isFakeStreamHandle(stream_addr)) {
            Modules.log.debug("sceMpegGetPcmAu got fake stream ID " + getFakeStreamID(stream_addr));
            mem.write32(au_addr, 0x56560002);
            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegGetPcmAu bad address "
                + String.format("0x%08X 0x%08X", stream_addr, au_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegGetAtracAu(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int stream_addr = cpu.gpr[5];
        int au_addr = cpu.gpr[6];
        int unk_addr = cpu.gpr[7];

        Modules.log.warn("PARTIAL:sceMpegGetAtracAu(mpeg=0x" + Integer.toHexString(mpeg)
            + ",stream=0x" + Integer.toHexString(stream_addr)
            + ",au=0x" + Integer.toHexString(au_addr)
            + ",unknown=0x" + Integer.toHexString(unk_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegGetAtracAu bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(stream_addr) && mem.isAddressGood(au_addr)) {
            // TODO
            mem.write32(au_addr, 0x56560003);

            cpu.gpr[2] = 0;
        } else if (isFakeStreamHandle(stream_addr)) {
            Modules.log.debug("sceMpegGetAtracAu got fake stream ID " + getFakeStreamID(stream_addr));
            mem.write32(au_addr, 0x56560003);
            if (enableMpeg) {
                mem.write32(au_addr + 4, mpegAtracCurrentTimestamp);
            }
            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegGetAtracAu bad address "
                + String.format("0x%08X 0x%08X", stream_addr, au_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegFlushStream(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpegFlushStream [0x500F0429]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpegFlushAllStream(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];

        Modules.log.warn("IGNORING:sceMpegFlushAllStream");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegFlushAllStream bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else {
            cpu.gpr[2] = 0;
        }
    }

    public void sceMpegAvcDecode(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int au_addr = cpu.gpr[5];
        int frameWidth = cpu.gpr[6];
        int buffer_addr = cpu.gpr[7];
        int init_addr = cpu.gpr[8];

        Modules.log.warn("UNIMPLEMENTED:sceMpegAvcDecode(mpeg=0x" + Integer.toHexString(mpeg)
            + ",au=0x" + Integer.toHexString(au_addr)
            + ",frameWidth=" + frameWidth
            + ",buffer=0x" + Integer.toHexString(buffer_addr)
            + ",init=0x" + Integer.toHexString(init_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegAvcDecode bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(au_addr) && mem.isAddressGood(buffer_addr) && mem.isAddressGood(init_addr)) {
            if (enableMpeg) {
                // TODO
                int au = mem.read32(au_addr);
                int buffer = mem.read32(buffer_addr);
                int init = mem.read32(init_addr);

                Modules.log.debug("sceMpegAvcDecode *au=0x" + Integer.toHexString(au)
                    + " *buffer=0x" + Integer.toHexString(buffer)
                    + " *init=" + init);

                mpegAvcCurrentTimestamp += (int)(90000 / 29.97); // value based on pmfplayer
                mem.write32(init_addr, 1);

                // Generate a random image...
                Random random = new Random();
                final int pixelSize = 3;
                for (int y = 0; y < 272; y += pixelSize) {
                    int address = buffer + y * frameWidth * 4;
                    final int width = Math.min(480, frameWidth);
                    for (int x = 0; x < width; x += pixelSize) {
                        int n = random.nextInt(256);
                        int pixel = 0xFF000000 | n << 16 | n << 8 | n;
                        for (int i = 0; i < pixelSize; i++) {
                            for (int j = 0; j < pixelSize; j++) {
                                mem.write32(address + (i * frameWidth + j) * 4, pixel);
                            }
                        }
                        address += pixelSize * 4;
                    }
                }

                if (isFakeAuHandle(au)) {
                    int type = getFakeAuType(au);
                    switch(type) {
                    case 1: Modules.log.debug("sceMpegAvcDecode got fake avc au"); break;
                    case 2: Modules.log.debug("sceMpegAvcDecode got fake pcm au"); break;
                    case 3: Modules.log.debug("sceMpegAvcDecode got fake atrac au"); break;
                    }
                }

                cpu.gpr[2] = 0;
            } else {
                // unimplemented
                cpu.gpr[2] = 0xDEADC0DE;
            }
        } else {
            Modules.log.warn("sceMpegAvcDecode bad address "
                + String.format("0x%08X 0x%08X", au_addr, buffer_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegAvcDecodeDetail(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        // unknown params

        Modules.log.warn("IGNORING:sceMpegAvcDecodeDetail(mpeg=0x" + Integer.toHexString(mpeg)
            + String.format("%08X %08X %08X %08X", cpu.gpr[5], cpu.gpr[6], cpu.gpr[7], cpu.gpr[8]));

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegAvcDecodeDetail bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else {
            // Fake success
            cpu.gpr[2] = 0;
        }
    }

    public void sceMpegAvcDecodeMode(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int mode_addr = cpu.gpr[5];

        Modules.log.warn("IGNORING:sceMpegAvcDecodeMode(mpeg=0x" + Integer.toHexString(mpeg)
            + ",mode=0x" + Integer.toHexString(mode_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegAvcDecodeMode bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(mode_addr)) {
            int unk = mem.read32(mode_addr);
            int mode = mem.read32(mode_addr + 4);

            Modules.log.debug("sceMpegAvcDecodeMode unk=0x" + Integer.toHexString(unk)
                + " mode=0x" + Integer.toHexString(mode));

            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegAvcDecodeMode bad address "
                + String.format("0x%08X", mode_addr));
            cpu.gpr[2] = -1;
        }
    }

    // noxa/pspplayer has no parameters and has a fake return
    public void sceMpegAvcDecodeStop(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int frameWidth = cpu.gpr[5];
        int buffer_addr = cpu.gpr[6];
        int status_addr = cpu.gpr[7];

        Modules.log.warn("IGNORING:sceMpegAvcDecodeStop(mpeg=0x" + Integer.toHexString(mpeg)
            + ",frameWidth=" + frameWidth
            + ",buffer=0x" + Integer.toHexString(buffer_addr)
            + ",status=0x" + Integer.toHexString(status_addr) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegAvcDecodeStop bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(buffer_addr) && mem.isAddressGood(status_addr)) {
            int status = 0; // TODO

            mem.write32(status_addr, status);

            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegAvcDecodeStop bad address "
                + String.format("0x%08X 0x%08X", buffer_addr, status_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegAvcDecodeFlush(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        Modules.log.warn("UNIMPLEMENTED:sceMpegAvcDecodeFlush "
            + String.format("%08X %08X %08X %08X", cpu.gpr[4], cpu.gpr[5], cpu.gpr[6], cpu.gpr[7]));

        cpu.gpr[2] = 0;
    }

    public void sceMpegAvcQueryYCbCrSize(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        Modules.log.warn("UNIMPLEMENTED:sceMpegAvcQueryYCbCrSize "
            + String.format("%08X %08X %08X %08X", cpu.gpr[4], cpu.gpr[5], cpu.gpr[6], cpu.gpr[7]));

        cpu.gpr[2] = 0;
    }

    public void sceMpegAvcInitYCbCr(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        Modules.log.warn("UNIMPLEMENTED:sceMpegAvcInitYCbCr "
            + String.format("%08X %08X %08X %08X", cpu.gpr[4], cpu.gpr[5], cpu.gpr[6], cpu.gpr[7]));

        cpu.gpr[2] = 0;
    }

    public void sceMpegAvcDecodeYCbCr(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        Modules.log.warn("UNIMPLEMENTED:sceMpegAvcDecodeYCbCr "
            + String.format("%08X %08X %08X %08X", cpu.gpr[4], cpu.gpr[5], cpu.gpr[6], cpu.gpr[7]));

        cpu.gpr[2] = 0;
    }

    public void sceMpegAvcDecodeStopYCbCr(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpegAvcDecodeStopYCbCr [0xF2930C9C]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpegAvcCsc(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpegAvcCsc [0x31BD0272]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpegAtracDecode(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int mpeg = cpu.gpr[4];
        int au_addr = cpu.gpr[5];
        int buffer_addr = cpu.gpr[6];
        int init = cpu.gpr[7];

        Modules.log.warn("IGNORING:sceMpegAtracDecode(mpeg=0x" + Integer.toHexString(mpeg)
            + ",au=0x" + Integer.toHexString(au_addr)
            + ",buffer=0x" + Integer.toHexString(buffer_addr)
            + ",init=0x" + Integer.toHexString(init) + ")");

        if (getMpegUid(mpeg) != mpegUid) {
            Modules.log.warn("sceMpegAtracDecode bad mpeg handle 0x" + Integer.toHexString(mpeg));
            cpu.gpr[2] = -1;
        } else if (mem.isAddressGood(au_addr) && mem.isAddressGood(buffer_addr)) {
            // TODO
            mpegAtracCurrentTimestamp += 4180;      // value based on pmfplayer
            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegAtracDecode bad address "
                + String.format("0x%08X 0x%08X", au_addr, buffer_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegRingbufferQueryMemSize(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        int packets = cpu.gpr[4];

        Modules.log.warn("PARTIAL:sceMpegRingbufferQueryMemSize(packets=" + packets + ")");

        int size = 0;

        // copied from noxa/pspplayer
        // packets = 4800, approx 10mb, too big?
        size = ( packets * 104 ) + ( packets * 2048 );
        Modules.log.debug("sceMpegRingbufferQueryMemSize noxa/pspplayer size=0x" + Integer.toHexString(size));

        // we use a 2mb cap, not sure if there is actually a cap or how big it is
        if (size > 0x200000)
            size = 0x200000;

        cpu.gpr[2] = size;
        Modules.log.debug("sceMpegRingbufferQueryMemSize ret=0x" + Integer.toHexString(cpu.gpr[2]));
    }

    public void sceMpegRingbufferConstruct(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int ringbuffer_addr = cpu.gpr[4];
        int packets = cpu.gpr[5];
        int data = cpu.gpr[6];
        int size = cpu.gpr[7]; // seems to match sceMpegQueryMemSize
        int callback_addr = cpu.gpr[8];
        int callback_args = cpu.gpr[9];

        Modules.log.warn("PARTIAL:sceMpegRingbufferConstruct(ringbuffer=0x" + Integer.toHexString(ringbuffer_addr)
            + ",packets=" + packets
            + ",data=0x" + Integer.toHexString(data)
            + ",size=" + size
            + ",callback=0x" + Integer.toHexString(callback_addr)
            + ",args=0x" + Integer.toHexString(callback_args) + ")");

        if (mem.isAddressGood(ringbuffer_addr)) {
            SceMpegRingbuffer ringbuffer = new SceMpegRingbuffer(packets, data, size, callback_addr, callback_args);
            ringbuffer.write(mem, ringbuffer_addr);

            cpu.gpr[2] = 0;
        } else {
            Modules.log.warn("sceMpegRingbufferConstruct bad address "
                + String.format("0x%08X", ringbuffer_addr));
            cpu.gpr[2] = -1;
        }
    }

    public void sceMpegRingbufferDestruct(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int ringbuffer_addr = cpu.gpr[4];

        Modules.log.warn("PARTIAL:sceMpegRingbufferDestruct(ringbuffer=0x" + Integer.toHexString(ringbuffer_addr) + ")");

        // nothing to do ... ?

        cpu.gpr[2] = 0;
    }

    public void sceMpegRingbufferPut(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int ringbuffer_addr = cpu.gpr[4];
        int numPackets = cpu.gpr[5];
        int available = cpu.gpr[6];

        Modules.log.warn("IGNORING:sceMpegRingbufferPut(ringbuffer=0x" + Integer.toHexString(ringbuffer_addr)
            + ",numPackets=" + numPackets
            + ",available=" + available + ")");

        if (numPackets < 0) {
            Modules.log.warn("sceMpegRingbufferPut numPackets=" + numPackets + " (less than 0!)");
            cpu.gpr[2] = 0; // check
        } else {
            if (enableMpeg) {
                SceMpegRingbuffer ringbuffer = new SceMpegRingbuffer(mem, ringbuffer_addr);
                ringbuffer.packetsFree -= numPackets;
                ringbuffer.write(mem, ringbuffer_addr);
            }

            cpu.gpr[2] = numPackets;
        }
    }

    // TODO return in bytes or packets?
    public void sceMpegRingbufferAvailableSize(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        int ringbuffer_addr = cpu.gpr[4];

        Modules.log.warn("PARTIAL:sceMpegRingbufferAvailableSize(ringbuffer=0x" + Integer.toHexString(ringbuffer_addr) + ")");

        //if (true) {
        if (enableMpeg) {
            SceMpegRingbuffer ringbuffer = new SceMpegRingbuffer(mem, ringbuffer_addr);
            cpu.gpr[2] = ringbuffer.packetsFree;
        } else {
            cpu.gpr[2] = 0; // fake
        }
    }

    public void sceMpeg_11CAB459(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpeg_11CAB459 [0x11CAB459]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpegNextAvcRpAu(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor

        Modules.log.warn("UNIMPLEMENTED:sceMpegNextAvcRpAu "
            + String.format("%08X %08X %08X %08X", cpu.gpr[4], cpu.gpr[5], cpu.gpr[6], cpu.gpr[7]));

        cpu.gpr[2] = 0;
    }

    public void sceMpeg_B27711A8(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpeg_B27711A8 [0xB27711A8]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpeg_D4DD6E75(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpeg_D4DD6E75 [0xD4DD6E75]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpeg_C345DED2(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpeg_C345DED2 [0xC345DED2]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpeg_AB0E9556(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpeg_AB0E9556 [0xAB0E9556]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpegAvcDecodeDetail2(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpegAvcDecodeDetail2 [0xCF3547A2]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceMpeg_988E9E12(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        System.out.println("Unimplemented NID function sceMpeg_988E9E12 [0x988E9E12]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public final HLEModuleFunction sceMpegQueryStreamOffsetFunction = new HLEModuleFunction("sceMpeg", "sceMpegQueryStreamOffset") {
        @Override
        public final void execute(Processor processor) {
            sceMpegQueryStreamOffset(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegQueryStreamOffset(processor);";
        }
    };

    public final HLEModuleFunction sceMpegQueryStreamSizeFunction = new HLEModuleFunction("sceMpeg", "sceMpegQueryStreamSize") {
        @Override
        public final void execute(Processor processor) {
            sceMpegQueryStreamSize(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegQueryStreamSize(processor);";
        }
    };

    public final HLEModuleFunction sceMpegInitFunction = new HLEModuleFunction("sceMpeg", "sceMpegInit") {
        @Override
        public final void execute(Processor processor) {
            sceMpegInit(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegInit(processor);";
        }
    };

    public final HLEModuleFunction sceMpegFinishFunction = new HLEModuleFunction("sceMpeg", "sceMpegFinish") {
        @Override
        public final void execute(Processor processor) {
            sceMpegFinish(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegFinish(processor);";
        }
    };

    public final HLEModuleFunction sceMpegQueryMemSizeFunction = new HLEModuleFunction("sceMpeg", "sceMpegQueryMemSize") {
        @Override
        public final void execute(Processor processor) {
            sceMpegQueryMemSize(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegQueryMemSize(processor);";
        }
    };

    public final HLEModuleFunction sceMpegCreateFunction = new HLEModuleFunction("sceMpeg", "sceMpegCreate") {
        @Override
        public final void execute(Processor processor) {
            sceMpegCreate(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegCreate(processor);";
        }
    };

    public final HLEModuleFunction sceMpegDeleteFunction = new HLEModuleFunction("sceMpeg", "sceMpegDelete") {
        @Override
        public final void execute(Processor processor) {
            sceMpegDelete(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegDelete(processor);";
        }
    };

    public final HLEModuleFunction sceMpegRegistStreamFunction = new HLEModuleFunction("sceMpeg", "sceMpegRegistStream") {
        @Override
        public final void execute(Processor processor) {
            sceMpegRegistStream(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegRegistStream(processor);";
        }
    };

    public final HLEModuleFunction sceMpegUnRegistStreamFunction = new HLEModuleFunction("sceMpeg", "sceMpegUnRegistStream") {
        @Override
        public final void execute(Processor processor) {
            sceMpegUnRegistStream(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegUnRegistStream(processor);";
        }
    };

    public final HLEModuleFunction sceMpegMallocAvcEsBufFunction = new HLEModuleFunction("sceMpeg", "sceMpegMallocAvcEsBuf") {
        @Override
        public final void execute(Processor processor) {
            sceMpegMallocAvcEsBuf(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegMallocAvcEsBuf(processor);";
        }
    };

    public final HLEModuleFunction sceMpegFreeAvcEsBufFunction = new HLEModuleFunction("sceMpeg", "sceMpegFreeAvcEsBuf") {
        @Override
        public final void execute(Processor processor) {
            sceMpegFreeAvcEsBuf(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegFreeAvcEsBuf(processor);";
        }
    };

    public final HLEModuleFunction sceMpegQueryAtracEsSizeFunction = new HLEModuleFunction("sceMpeg", "sceMpegQueryAtracEsSize") {
        @Override
        public final void execute(Processor processor) {
            sceMpegQueryAtracEsSize(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegQueryAtracEsSize(processor);";
        }
    };

    public final HLEModuleFunction sceMpegQueryPcmEsSizeFunction = new HLEModuleFunction("sceMpeg", "sceMpegQueryPcmEsSize") {
        @Override
        public final void execute(Processor processor) {
            sceMpegQueryPcmEsSize(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegQueryPcmEsSize(processor);";
        }
    };

    public final HLEModuleFunction sceMpegInitAuFunction = new HLEModuleFunction("sceMpeg", "sceMpegInitAu") {
        @Override
        public final void execute(Processor processor) {
            sceMpegInitAu(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegInitAu(processor);";
        }
    };

    public final HLEModuleFunction sceMpegChangeGetAvcAuModeFunction = new HLEModuleFunction("sceMpeg", "sceMpegChangeGetAvcAuMode") {
        @Override
        public final void execute(Processor processor) {
            sceMpegChangeGetAvcAuMode(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegChangeGetAvcAuMode(processor);";
        }
    };

    public final HLEModuleFunction sceMpegChangeGetAuModeFunction = new HLEModuleFunction("sceMpeg", "sceMpegChangeGetAuMode") {
        @Override
        public final void execute(Processor processor) {
            sceMpegChangeGetAuMode(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegChangeGetAuMode(processor);";
        }
    };

    public final HLEModuleFunction sceMpegGetAvcAuFunction = new HLEModuleFunction("sceMpeg", "sceMpegGetAvcAu") {
        @Override
        public final void execute(Processor processor) {
            sceMpegGetAvcAu(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegGetAvcAu(processor);";
        }
    };

    public final HLEModuleFunction sceMpegGetPcmAuFunction = new HLEModuleFunction("sceMpeg", "sceMpegGetPcmAu") {
        @Override
        public final void execute(Processor processor) {
            sceMpegGetPcmAu(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegGetPcmAu(processor);";
        }
    };

    public final HLEModuleFunction sceMpegGetAtracAuFunction = new HLEModuleFunction("sceMpeg", "sceMpegGetAtracAu") {
        @Override
        public final void execute(Processor processor) {
            sceMpegGetAtracAu(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegGetAtracAu(processor);";
        }
    };

    public final HLEModuleFunction sceMpegFlushStreamFunction = new HLEModuleFunction("sceMpeg", "sceMpegFlushStream") {
        @Override
        public final void execute(Processor processor) {
            sceMpegFlushStream(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegFlushStream(processor);";
        }
    };

    public final HLEModuleFunction sceMpegFlushAllStreamFunction = new HLEModuleFunction("sceMpeg", "sceMpegFlushAllStream") {
        @Override
        public final void execute(Processor processor) {
            sceMpegFlushAllStream(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegFlushAllStream(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcDecodeFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcDecode") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcDecode(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcDecode(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcDecodeDetailFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcDecodeDetail") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcDecodeDetail(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcDecodeDetail(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcDecodeModeFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcDecodeMode") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcDecodeMode(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcDecodeMode(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcDecodeStopFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcDecodeStop") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcDecodeStop(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcDecodeStop(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcDecodeFlushFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcDecodeFlush") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcDecodeFlush(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcDecodeFlush(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcQueryYCbCrSizeFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcQueryYCbCrSize") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcQueryYCbCrSize(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcQueryYCbCrSize(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcInitYCbCrFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcInitYCbCr") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcInitYCbCr(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcInitYCbCr(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcDecodeYCbCrFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcDecodeYCbCr") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcDecodeYCbCr(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcDecodeYCbCr(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcDecodeStopYCbCrFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcDecodeStopYCbCr") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcDecodeStopYCbCr(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcDecodeStopYCbCr(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcCscFunction = new HLEModuleFunction("sceMpeg", "sceMpegAvcCsc") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcCsc(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcCsc(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAtracDecodeFunction = new HLEModuleFunction("sceMpeg", "sceMpegAtracDecode") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAtracDecode(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAtracDecode(processor);";
        }
    };

    public final HLEModuleFunction sceMpegRingbufferQueryMemSizeFunction = new HLEModuleFunction("sceMpeg", "sceMpegRingbufferQueryMemSize") {
        @Override
        public final void execute(Processor processor) {
            sceMpegRingbufferQueryMemSize(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegRingbufferQueryMemSize(processor);";
        }
    };

    public final HLEModuleFunction sceMpegRingbufferConstructFunction = new HLEModuleFunction("sceMpeg", "sceMpegRingbufferConstruct") {
        @Override
        public final void execute(Processor processor) {
            sceMpegRingbufferConstruct(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegRingbufferConstruct(processor);";
        }
    };

    public final HLEModuleFunction sceMpegRingbufferDestructFunction = new HLEModuleFunction("sceMpeg", "sceMpegRingbufferDestruct") {
        @Override
        public final void execute(Processor processor) {
            sceMpegRingbufferDestruct(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegRingbufferDestruct(processor);";
        }
    };

    public final HLEModuleFunction sceMpegRingbufferPutFunction = new HLEModuleFunction("sceMpeg", "sceMpegRingbufferPut") {
        @Override
        public final void execute(Processor processor) {
            sceMpegRingbufferPut(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegRingbufferPut(processor);";
        }
    };

    public final HLEModuleFunction sceMpegRingbufferAvailableSizeFunction = new HLEModuleFunction("sceMpeg", "sceMpegRingbufferAvailableSize") {
        @Override
        public final void execute(Processor processor) {
            sceMpegRingbufferAvailableSize(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegRingbufferAvailableSize(processor);";
        }
    };

    public final HLEModuleFunction sceMpeg_11CAB459Function = new HLEModuleFunction("sceMpeg", "sceMpeg_11CAB459") {
        @Override
        public final void execute(Processor processor) {
            sceMpeg_11CAB459(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpeg_11CAB459(processor);";
        }
    };

    public final HLEModuleFunction sceMpegNextAvcRpAuFunction = new HLEModuleFunction("sceMpeg", "sceMpegNextAvcRpAu") {
        @Override
        public final void execute(Processor processor) {
            sceMpegNextAvcRpAu(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegNextAvcRpAu(processor);";
        }
    };

    public final HLEModuleFunction sceMpeg_B27711A8Function = new HLEModuleFunction("sceMpeg", "sceMpeg_B27711A8") {
        @Override
        public final void execute(Processor processor) {
            sceMpeg_B27711A8(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpeg_B27711A8(processor);";
        }
    };

    public final HLEModuleFunction sceMpeg_D4DD6E75Function = new HLEModuleFunction("sceMpeg", "sceMpeg_D4DD6E75") {
        @Override
        public final void execute(Processor processor) {
            sceMpeg_D4DD6E75(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpeg_D4DD6E75(processor);";
        }
    };

    public final HLEModuleFunction sceMpeg_C345DED2Function = new HLEModuleFunction("sceMpeg", "sceMpeg_C345DED2") {
        @Override
        public final void execute(Processor processor) {
            sceMpeg_C345DED2(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpeg_C345DED2(processor);";
        }
    };

    public final HLEModuleFunction sceMpeg_AB0E9556Function = new HLEModuleFunction("sceMpeg", "sceMpeg_AB0E9556") {
        @Override
        public final void execute(Processor processor) {
            sceMpeg_AB0E9556(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpeg_AB0E9556(processor);";
        }
    };

    public final HLEModuleFunction sceMpegAvcDecodeDetail2Function = new HLEModuleFunction("sceMpeg", "sceMpegAvcDecodeDetail2") {
        @Override
        public final void execute(Processor processor) {
            sceMpegAvcDecodeDetail2(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpegAvcDecodeDetail2(processor);";
        }
    };

    public final HLEModuleFunction sceMpeg_988E9E12Function = new HLEModuleFunction("sceMpeg", "sceMpeg_988E9E12") {
        @Override
        public final void execute(Processor processor) {
            sceMpeg_988E9E12(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceMpegModule.sceMpeg_988E9E12(processor);";
        }
    };

}
