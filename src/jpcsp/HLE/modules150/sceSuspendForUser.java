/* This autogenerated file is part of jpcsp. */
/*
This file is part of jpcsp.

Jpcsp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Jpcsp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Jpcsp.  If not, see <http://www.gnu.org/licenses/>.
 */

package jpcsp.HLE.modules150;

import jpcsp.HLE.Modules;
import jpcsp.HLE.modules.HLEModule;
import jpcsp.HLE.modules.HLEModuleFunction;
import jpcsp.HLE.modules.HLEModuleManager;

import jpcsp.Memory;
import jpcsp.Processor;

import jpcsp.Allegrex.CpuState; // New-Style Processor

public class sceSuspendForUser implements HLEModule {
    @Override
    public String getName() { return "sceSuspendForUser"; }

    @Override
    public void installModule(HLEModuleManager mm, int version) {
        if (version >= 150) {

            mm.addFunction(sceKernelPowerLockFunction, 0xEADB1BD7);
            mm.addFunction(sceKernelPowerUnlockFunction, 0x3AEE7261);
            mm.addFunction(sceKernelPowerTickFunction, 0x090CCB3F);
            mm.addFunction(sceKernelVolatileMemLockFunction, 0x3E0271D3);
            mm.addFunction(sceKernelVolatileMemTryLockFunction, 0xA14F40B2);
            mm.addFunction(sceKernelVolatileMemUnlockFunction, 0xA569E425);

        }
    }

    @Override
    public void uninstallModule(HLEModuleManager mm, int version) {
        if (version >= 150) {

            mm.removeFunction(sceKernelPowerLockFunction);
            mm.removeFunction(sceKernelPowerUnlockFunction);
            mm.removeFunction(sceKernelPowerTickFunction);
            mm.removeFunction(sceKernelVolatileMemLockFunction);
            mm.removeFunction(sceKernelVolatileMemTryLockFunction);
            mm.removeFunction(sceKernelVolatileMemUnlockFunction);

        }
    }


    public void sceKernelPowerLock(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor

        Modules.log.debug("IGNORING:sceKernelPowerLock");

        cpu.gpr[2] = 0;
    }

    public void sceKernelPowerUnlock(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor

        Modules.log.debug("IGNORING:sceKernelPowerUnlock");

        cpu.gpr[2] = 0;
    }

    public void sceKernelPowerTick(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor

        Modules.log.debug("IGNORING:sceKernelPowerTick");

        cpu.gpr[2] = 0;
    }

    public void sceKernelVolatileMemLock(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        Modules.log.warn("Unimplemented NID function sceKernelVolatileMemLock [0x3E0271D3]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceKernelVolatileMemTryLock(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        Modules.log.warn("Unimplemented NID function sceKernelVolatileMemTryLock [0xA14F40B2]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public void sceKernelVolatileMemUnlock(Processor processor) {
        CpuState cpu = processor.cpu; // New-Style Processor
        // Processor cpu = processor; // Old-Style Processor
        Memory mem = Processor.memory;

        /* put your own code here instead */

        // int a0 = cpu.gpr[4];  int a1 = cpu.gpr[5];  ...  int t3 = cpu.gpr[11];
        // float f12 = cpu.fpr[12];  float f13 = cpu.fpr[13];  ... float f19 = cpu.fpr[19];

        Modules.log.warn("Unimplemented NID function sceKernelVolatileMemUnlock [0xA569E425]");

        cpu.gpr[2] = 0xDEADC0DE;

        // cpu.gpr[2] = (int)(result & 0xffffffff);  cpu.gpr[3] = (int)(result  32); cpu.fpr[0] = result;
    }

    public final HLEModuleFunction sceKernelPowerLockFunction = new HLEModuleFunction("sceSuspendForUser", "sceKernelPowerLock") {
        @Override
        public final void execute(Processor processor) {
            sceKernelPowerLock(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceSuspendForUserModule.sceKernelPowerLock(processor);";
        }
    };

    public final HLEModuleFunction sceKernelPowerUnlockFunction = new HLEModuleFunction("sceSuspendForUser", "sceKernelPowerUnlock") {
        @Override
        public final void execute(Processor processor) {
            sceKernelPowerUnlock(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceSuspendForUserModule.sceKernelPowerUnlock(processor);";
        }
    };

    public final HLEModuleFunction sceKernelPowerTickFunction = new HLEModuleFunction("sceSuspendForUser", "sceKernelPowerTick") {
        @Override
        public final void execute(Processor processor) {
            sceKernelPowerTick(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceSuspendForUserModule.sceKernelPowerTick(processor);";
        }
    };

    public final HLEModuleFunction sceKernelVolatileMemLockFunction = new HLEModuleFunction("sceSuspendForUser", "sceKernelVolatileMemLock") {
        @Override
        public final void execute(Processor processor) {
            sceKernelVolatileMemLock(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceSuspendForUserModule.sceKernelVolatileMemLock(processor);";
        }
    };

    public final HLEModuleFunction sceKernelVolatileMemTryLockFunction = new HLEModuleFunction("sceSuspendForUser", "sceKernelVolatileMemTryLock") {
        @Override
        public final void execute(Processor processor) {
            sceKernelVolatileMemTryLock(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceSuspendForUserModule.sceKernelVolatileMemTryLock(processor);";
        }
    };

    public final HLEModuleFunction sceKernelVolatileMemUnlockFunction = new HLEModuleFunction("sceSuspendForUser", "sceKernelVolatileMemUnlock") {
        @Override
        public final void execute(Processor processor) {
            sceKernelVolatileMemUnlock(processor);
        }
        @Override
        public final String compiledString() {
            return "jpcsp.HLE.Modules.sceSuspendForUserModule.sceKernelVolatileMemUnlock(processor);";
        }
    };

};
